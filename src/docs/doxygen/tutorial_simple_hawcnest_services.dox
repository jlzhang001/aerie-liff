/*!

\page tutorial_simple_hawcnest_services Simple HAWCNest Services

\tableofcontents

\section the_makefile The Makefile

Look first at the Makefile. 
This is the instructions on how to build the example and is suitable for 
copying into most projects. Describing make is beyond the scope of this 
tutorial, but just to point out the major features:

These lines are the ones intended to be modified by the user. The first 
specifies the code to be built (it defaults to just build all of the .cc 
files) and the second is the name of the resulting executable. Note that 
this makefile will take the specified and build all of it against the aerie 
projects, but it will not, for instance, create more than one executable.

\code
# Source files.  Replace the wildcard with a list of .cc files as desired
USER_SRCS = $(wildcard *.cc)

# Output executable.  Rename as desired
USER_EXE  = hawcnest-simple-service
\endcode

One other major feature of the Makefile is worth noting. The lines:

\code
HAWCCONFIG = hawc-config

OBJS = $(USER_SRCS:.cc=.o)

# Compile and link flags
CXXFLAGS = $(shell $(HAWCCONFIG) --cppflags)
LDFLAGS  = $(shell $(HAWCCONFIG) --ldflags)
\endcode

are what is used to locate the Aerie installation. 
The hawc-config executable is built by Aerie and is used to provide the 
necessary compilation and linking lines necessary to build against Aerie. 
If that executable is not in your path, the Makefile will not know where to 
find your aerie installation. As a quick check of whether or not hawc-config 
is present and working you can just run it by hand:

\verbatim
% hawc-config --cppflags
% hawc-config --ldflags
\endverbatim

If you get something that looks like g++ compilation flags, that's a good sign.
If the executable cannot be found, return to the page on installing Aerie 
and make sure that Aerie is installed correctly.

\section building_and_running Building and Running

If hawc-config is found, go ahead and compile the example and check that the 
hawcnest-simple-service executable is built successfully.

\verbatim
% cd aerie-tutorial/basics/simple-hawcnest-service
% make
% ls
hawcnest-simple-service*  Makefile                    simple-hawcnest-service.o
Make-depend               simple-hawcnest-service.cc
\endverbatim

The files simple-hawcnest-service.o and Make-depend are generated by the build and can be ignored. If the executable hawcnest-simple-service exists, then that's good and we can run it.
\verbatim
% ./hawcnest-simple-service
\endverbatim

It just prints out some integers along with some logging statements.

\section the_code The Code

Take a look at the the file simple-hawcnest-service.cc. There is one base 
class, ServiceBase, defined and two subclasses, SingleIntegerService and 
MultipleIntegerService. If the concept of base classes and inheritance is new, 
I'd suggest reading up on inheritance and virtual methods a bit before 
continuing because explaining it is beyond the scope of this tutorial.

The file is heavily commented and should cover most detailed questions. 
The methods DefaultConfiguration, Initialize, and Finish are used by the 
framework and should be included in new code. DefaultConfiguration and 
Initialize are used to specify and retrieve the configuration parameters. 
The method DoSomething is unique to this example. The idea of this example 
is that we have one "job" to do: return an integer. There are two ways to 
do this. The first example, SingleIntegerService just returns a single 
user-configurable integer each time. The second example 
MultipleIntegerService takes a vector of integers as a configuration 
parameter and just cycles through them.

In the main function, an instance of HAWCNest is created and one instance 
of each of these services is created and a list of 10 integers is retrieved 
from each service, showing how the framework works.

\section fiddling_around Fiddling Around

Here are some suggestions for how to change this example:
<ul>
<li>Change the name of the compiled executable</li>
<li>Return floats or strings instead of integers. Services can be configured with floats and strings as parameters so it should be easy.</li>
<li>Write a third implementation which returns a random number.</li>
<li>Fiddle with the logging. Generate a few log_fatal messages on purpose.</li>
<li>Generate a whole new type of service and use it in parallel with the two in this example.</li>
</ul>

*/

